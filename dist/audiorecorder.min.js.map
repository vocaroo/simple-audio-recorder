{"version":3,"file":"audiorecorder.min.js","sources":["../src/mp3worker/WorkerEncoder.js","../src/Timer.js","../src/AudioRecorder.js","../src/utils.js"],"sourcesContent":["let workerStates = {\n\tINACTIVE : 0,\n\tLOADING : 1,\n\tREADY : 2,\n\tERROR : 3\n}\n\nlet worker = null;\nlet workerState = workerStates.INACTIVE;\nlet workerStateChangeCallbacks = [];\nlet jobCallbacks = {};\n\nfunction uuidv4() { // https://stackoverflow.com/a/2117523\n\treturn ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n\t\t(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n\t);\n}\n\nfunction notifyWorkerState(newState) {\n\tworkerState = newState;\n\n\tfor (let callback of workerStateChangeCallbacks) {\n\t\tcallback();\n\t}\n\n\tworkerStateChangeCallbacks = [];\n}\n\n// This hack required to load worker from another domain (e.g. a CDN)\n// https://stackoverflow.com/a/62914052\nfunction getWorkerCrossDomainURL(url) {\n\tconst content = `importScripts(\"${url}\");`;\n\treturn URL.createObjectURL(new Blob([content], {type : \"text/javascript\"}));\n}\n\nfunction loadWorker(workerUrl) {\n\tif (/^https?:\\/\\//.test(workerUrl)) { // Is it an absolute URL? Then consider it cross domain.\n\t\tworkerUrl = getWorkerCrossDomainURL(workerUrl);\n\t}\n\n\tworker = new Worker(workerUrl);\n\tworkerState = workerStates.LOADING;\n\n\tworker.onmessage = (event) => {\n\t\tswitch (event.data.message) {\n\t\t\tcase \"ready\":\n\t\t\t\tnotifyWorkerState(workerStates.READY);\n\t\t\t\tbreak;\n\t\t\tcase \"encoded\":\n\t\t\t\tif (event.data.jobId in jobCallbacks) {\n\t\t\t\t\tjobCallbacks[event.data.jobId].onencoded(event.data.srcBufLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"data\":\n\t\t\t\tif (event.data.jobId in jobCallbacks) {\n\t\t\t\t\tjobCallbacks[event.data.jobId].ondataavailable(event.data.data);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"stopped\":\n\t\t\t\tif (event.data.jobId in jobCallbacks) {\n\t\t\t\t\tjobCallbacks[event.data.jobId].onstopped();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tworker.onerror = (event) => {\n\t\tconsole.error(\"mp3worker error. Is the worker URL correct?\");\n\t\tnotifyWorkerState(workerStates.ERROR);\n\t};\n}\n\n// Callbacks:\n// - ondataavailable\n// - onstopped\nexport default class WorkerEncoder {\n\tconstructor(options) {\n\t\tthis.jobId = uuidv4();\n\t\tthis.options = options;\n\t\tthis.queuedData = 0;\n\n\t\tjobCallbacks[this.jobId] = {\n\t\t\tonencoded : (srcBufLen) => {\n\t\t\t\tthis.queuedData -= srcBufLen;\n\t\t\t},\n\t\t\tondataavailable : (data) => {\n\t\t\t\tthis.ondataavailable && this.ondataavailable(data);\n\t\t\t},\n\t\t\tonstopped : () => {\n\t\t\t\tdelete jobCallbacks[this.jobId]; // Clean up\n\t\t\t\tthis.onstopped && this.onstopped();\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic preload(workerUrl) {\n\t\tif (workerState == workerStates.INACTIVE || workerState == workerStates.ERROR) {\n\t\t\tloadWorker(workerUrl);\n\t\t}\n\t}\n\n\tstatic waitForWorker(workerUrl) {\n\t\tif (workerState == workerStates.READY) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\t// Worker loading already failed, try again...\n\t\t\tif (workerState == workerStates.INACTIVE || workerState == workerStates.ERROR) {\n\t\t\t\tloadWorker(workerUrl);\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tworkerStateChangeCallbacks.push(() => {\n\t\t\t\t\tif (workerState == workerStates.READY) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet error = new Error(\"MP3 worker failed\");\n\t\t\t\t\t\terror.name = \"WorkerError\";\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tstart() {\n\t\tworker.postMessage({\n\t\t\tcommand : \"start\",\n\t\t\tjobId : this.jobId,\n\t\t\toptions : this.options\n\t\t});\n\t}\n\n\tsendData(buffers) {\n\t\t// Check for an empty buffer\n\t\tif (buffers && buffers.length > 0 && buffers[0].length > 0) {\n\t\t\tthis.queuedData += buffers[0].length;\n\t\t\t\n\t\t\tworker.postMessage({\n\t\t\t\tcommand : \"data\",\n\t\t\t\tjobId : this.jobId,\n\t\t\t\tbuffers : buffers\n\t\t\t});\n\t\t}\n\t}\n\t\n\t// Amount of data that is not yet encoded.\n\tgetQueuedDataLen() {\n\t\treturn this.queuedData;\n\t}\n\n\tstop() {\n\t\tworker.postMessage({\n\t\t\tcommand : \"stop\",\n\t\t\tjobId : this.jobId\n\t\t});\n\t}\n}\n","\nexport default class Timer {\n\tconstructor() {\n\t\tthis.reset();\n\t}\n\n\treset() {\n\t\tthis.startTime = null; // May be modified when resuming, so not the true start time.\n\t\tthis.stoppedTime = null;\n\t}\n\n\tstart() {\n\t\tif (!this.startTime) {\n\t\t\tthis.startTime = Date.now();\n\t\t}\n\n\t\tif (this.stoppedTime) {\n\t\t\t// Skip time forward by the time length we were stopped\n\t\t\tthis.startTime += Date.now() - this.stoppedTime;\n\t\t\tthis.stoppedTime = null;\n\t\t}\n\t}\n\t\n\tresetAndStart() {\n\t\tthis.reset();\n\t\tthis.start();\n\t}\n\n\tstop() {\n\t\tif (!this.stoppedTime) {\n\t\t\tthis.stoppedTime = Date.now();\n\t\t}\n\t}\n\n\tgetTime() {\n\t\tif (this.startTime) {\n\t\t\tif (this.stoppedTime) {\n\t\t\t\treturn this.stoppedTime - this.startTime;\n\t\t\t} else {\n\t\t\t\treturn Date.now() - this.startTime;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n","import WorkerEncoder from \"./mp3worker/WorkerEncoder.js\";\nimport Timer from \"./Timer.js\";\nimport {stopStream, detectIOS, detectSafari} from \"./utils.js\";\n\nfunction getAudioContextCtor() {\n\treturn window.AudioContext || window.webkitAudioContext;\n}\n// Don't use audio worklet on iOS or safari, fall back to ScriptProcessor.\n// There are issues with dropped incoming audio data after ~45 seconds. Thus, the resulting audio would be shorter and sped up / glitchy.\n// Curiously, these same issues are present if *not using* AudioWorklet on Chrome\nfunction isAudioWorkletSupported() {\n\treturn window.AudioWorklet && !detectIOS() && !detectSafari();\n}\n\nconst states = {\n\tSTOPPED : 0,\n\tRECORDING : 1,\n\tPAUSED : 2,\n\tSTARTING : 3,\n\tSTOPPING : 4\n};\n\nconst DEFAULT_OPTIONS = {\n\trecordingGain : 1,\n\tencoderBitRate : 96,\n\tstreaming : false,\n\tstreamBufferSize : 50000,\n\tforceScriptProcessor : false,\n\tconstraints : {\n\t\tchannelCount : 1,\n\t\tautoGainControl : true,\n\t\techoCancellation : true,\n\t\tnoiseSuppression : true\n\t}\n};\n\nlet workerUrl = null;\n\nfunction createCancelStartError() {\n\tlet error = new Error(\"AudioRecorder start cancelled by call to stop\");\n\terror.name = \"CancelStartError\";\n\treturn error;\n}\n\nfunction getNumberOfChannels(stream) {\n\tlet audioTracks = stream.getAudioTracks();\n\t\n\tif (audioTracks.length < 1) {\n\t\tthrow new Error(\"No audio tracks in user media stream\");\n\t}\n\t\n\tlet trackSettings = audioTracks[0].getSettings();\n\treturn \"channelCount\" in trackSettings ? trackSettings.channelCount : 1;\n}\n\n// Worklet does nothing more than pass the data out, to be actually encoded by a regular Web Worker\n// Previously this was rewritten to do the encoding within an AudioWorklet, and it was all very nice and clean\n// but apparently doing anything that uses much CPU in a AudioWorklet will cause glitches in some browsers.\n// So, it's best to do the encoding in a regular Web Worker.\nlet AUDIO_OUTPUT_MODULE_URL = null;\n\nfunction getAudioOutputModuleUrl() {\n\tif (AUDIO_OUTPUT_MODULE_URL) {\n\t\treturn AUDIO_OUTPUT_MODULE_URL;\n\t}\n\n\tAUDIO_OUTPUT_MODULE_URL = URL.createObjectURL(new Blob([`\n\t\tclass AudioOutputProcessor extends AudioWorkletProcessor {\n\t\t\tprocess(inputs, outputs) {\n\t\t\t\tthis.port.postMessage(inputs[0]);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tregisterProcessor(\"audio-output-processor\", AudioOutputProcessor);\n\t`], {type : \"application/javascript\"}));\n\n\treturn AUDIO_OUTPUT_MODULE_URL;\n}\n\n/*\nCallbacks:\n\tondataavailable\n\tonstart - called when recording successfully started\n\tonstop - called when all data finished encoding and was output\n\tonerror - error starting recording\n*/\nexport default class AudioRecorder {\n\tconstructor(options) {\n\t\tthis.options = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options\n\t\t};\n\n\t\tthis.state = states.STOPPED;\n\t\tthis.audioContext = null;\n\t\tthis.encoder = null;\n\t\tthis.encodedData = null;\n\t\tthis.stopPromiseResolve = null;\n\t\tthis.stopPromiseReject = null;\n\t\tthis.timer = new Timer();\n\t}\n\t\n\tstatic isRecordingSupported() {\n\t\treturn getAudioContextCtor() && navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;\n\t}\n\t\n\tstatic preload(_workerUrl) {\n\t\tworkerUrl = _workerUrl;\n\t\tWorkerEncoder.preload(workerUrl);\n\t}\n\t\n\t// Will we use AudioWorklet?\n\tuseAudioWorklet() {\n\t\treturn isAudioWorkletSupported() && !this.options.forceScriptProcessor;\n\t}\n\t\n\tcreateAndStartEncoder(numberOfChannels) {\n\t\tthis.encoder = new WorkerEncoder({\n\t\t\toriginalSampleRate : this.audioContext.sampleRate,\n\t\t\tnumberOfChannels : numberOfChannels,\n\t\t\tencoderBitRate : this.options.encoderBitRate,\n\t\t\tstreamBufferSize : this.options.streamBufferSize\n\t\t});\n\n\t\tthis.encoder.ondataavailable = (data) => {\n\t\t\tif (this.options.streaming) {\n\t\t\t\tthis.ondataavailable && this.ondataavailable(data);\n\t\t\t} else {\n\t\t\t\tthis.encodedData.push(data);\n\t\t\t}\n\t\t};\n\n\t\tthis.encoder.onstopped = () => {\n\t\t\tthis.state = states.STOPPED;\n\t\t\tlet mp3Blob = this.options.streaming ? undefined : new Blob(this.encodedData, {type : \"audio/mpeg\"});\n\t\t\tthis.onstop && this.onstop(mp3Blob);\n\t\t\tthis.stopPromiseResolve(mp3Blob);\n\t\t};\n\n\t\tthis.encoder.start();\n\t}\n\n\tcreateOutputNode(numberOfChannels) {\t\t\n\t\tif (this.useAudioWorklet()) {\n\t\t\tconsole.log(\"Using AudioWorklet\");\n\n\t\t\tthis.outputNode = new AudioWorkletNode(this.audioContext, \"audio-output-processor\", {numberOfOutputs : 0});\n\n\t\t\tthis.outputNode.port.onmessage = ({data}) => {\n\t\t\t\tif (this.state == states.RECORDING) {\n\t\t\t\t\tthis.encoder.sendData(data);\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tconsole.log(\"Using ScriptProcessorNode\");\n\t\t\t\n\t\t\tthis.outputNode = this.audioContext.createScriptProcessor(4096, numberOfChannels, numberOfChannels);\n\n\t\t\tthis.outputNode.connect(this.audioContext.destination);\n\t\t\tthis.outputNode.onaudioprocess = (event) => {\n\t\t\t\tif (this.state == states.RECORDING) {\n\t\t\t\t\tlet inputBuffer = event.inputBuffer;\n\t\t\t\t\tlet buffers = [];\n\n\t\t\t\t\tfor (let i = 0; i < inputBuffer.numberOfChannels; i ++) {\n\t\t\t\t\t\tbuffers.push(inputBuffer.getChannelData(i));\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.encoder.sendData(buffers);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\t\n\tcreateAudioNodes(numberOfChannels) {\n\t\tthis.createOutputNode(numberOfChannels);\n\t\t\n\t\tthis.recordingGainNode = this.audioContext.createGain();\n\t\tthis.setRecordingGain(this.options.recordingGain);\n\t\tthis.recordingGainNode.connect(this.outputNode);\n\n\t\tthis.sourceNode = this.audioContext.createMediaStreamSource(this.stream);\n\t\tthis.sourceNode.connect(this.recordingGainNode);\n\t}\n\n\tcleanupAudioNodes() {\n\t\tif (this.stream) {\n\t\t\tstopStream(this.stream);\n\t\t\tthis.stream = null;\n\t\t}\n\t\t\n\t\tif (this.useAudioWorklet()) {\n\t\t\tthis.outputNode && (this.outputNode.port.onmessage = null);\n\t\t} else {\n\t\t\tthis.outputNode && (this.outputNode.onaudioprocess = null);\n\t\t}\n\t\t\n\t\tthis.outputNode && this.outputNode.disconnect();\n\t\tthis.recordingGainNode && this.recordingGainNode.disconnect();\n\t\tthis.sourceNode && this.sourceNode.disconnect();\n\t\tthis.audioContext && this.audioContext.close();\n\t}\n\n\tsetRecordingGain(gain) {\n\t\tthis.options.recordingGain = gain;\n\n\t\tif (this.recordingGainNode) {\n\t\t\tthis.recordingGainNode.gain.setTargetAtTime(gain, this.audioContext.currentTime, 0.01);\n\t\t}\n\t}\n\t\n\tget time() {\n\t\treturn this.timer.getTime();\n\t}\n\t\n\t// Get the amount of data left to be encoded.\n\t// Useful to estimate if STOPPING state (encoding still ongoing) will last a while.\n\tgetEncodingQueueSize() {\n\t\treturn this.encoder ? this.encoder.getQueuedDataLen() : 0;\n\t}\n\t\n\t// Called after every \"await\" in start(), to check that stop wasn't called\n\t// and we should abandon starting\n\tstoppingCheck() {\n\t\tif (this.state == states.STOPPING) {\n\t\t\tthrow createCancelStartError();\n\t\t}\n\t}\n\n\tasync __start(paused) {\n\t\tif (this.state != states.STOPPED) {\n\t\t\tthrow new Error(\"Called start when not in stopped state\");\n\t\t}\n\t\t\n\t\tif (workerUrl == null) {\n\t\t\tthrow new Error(\"preload was not called on AudioRecorder\");\n\t\t}\n\t\t\n\t\tthis.state = states.STARTING;\n\t\tthis.encodedData = [];\n\t\tthis.stream = null;\n\t\t\n\t\ttry {\n\t\t\tawait WorkerEncoder.waitForWorker(workerUrl);\n\t\t\tthis.stoppingCheck();\n\t\t\t\n\t\t\t// If a constraint is set, pass them, otherwise just pass true\n\t\t\tlet constraints = Object.keys(this.options.constraints).length > 0 ? this.options.constraints : true;\n\t\t\t\n\t\t\tthis.stream = await navigator.mediaDevices.getUserMedia({audio : constraints});\n\t\t\tthis.stoppingCheck();\n\t\t\t\n\t\t\tconst _AudioContext = getAudioContextCtor();\n\t\t\tthis.audioContext = new _AudioContext();\n\t\t\t\n\t\t\tif (this.useAudioWorklet()) {\n\t\t\t\tawait this.audioContext.audioWorklet.addModule(getAudioOutputModuleUrl(), {credentials : \"omit\"});\n\t\t\t\tthis.stoppingCheck();\n\t\t\t}\n\t\t\t\n\t\t\t// Channel count must be gotten from the stream, as it might not have supported\n\t\t\t// the desired amount specified in the constraints\n\t\t\tlet numberOfChannels = getNumberOfChannels(this.stream);\n\t\t\t\n\t\t\t// Successfully recording!\n\t\t\tthis.createAndStartEncoder(numberOfChannels);\n\t\t\tthis.createAudioNodes(numberOfChannels);\n\n\t\t\tif (paused) {\n\t\t\t\tthis.timer.reset();\n\t\t\t\tthis.state = states.PAUSED;\n\t\t\t} else {\n\t\t\t\tthis.timer.resetAndStart();\n\t\t\t\tthis.state = states.RECORDING;\n\t\t\t}\n\n\t\t\tthis.onstart && this.onstart();\n\t\t} catch (error) {\n\t\t\tlet startWasCancelled = this.state == states.STOPPING;\n\t\t\tthis.cleanupAudioNodes();\n\t\t\t\n\t\t\t// Reset so can attempt start again\n\t\t\tthis.state = states.STOPPED;\n\t\t\t\n\t\t\t// Reject the stop promise now we have cleaned up and are in STOPPED state and ready to start() again\n\t\t\tif (startWasCancelled) {\n\t\t\t\tthis.stopPromiseReject(error);\n\t\t\t}\n\t\t\t\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync __stop() {\n\t\tthis.timer.stop();\n\t\t\n\t\tif (this.state == states.RECORDING || this.state == states.PAUSED) {\n\t\t\t// Stop recording, but encoding may not have finished yet,\n\t\t\t// so we enter the stopping state.\n\t\t\tthis.state = states.STOPPING;\n\t\t\t\n\t\t\tthis.cleanupAudioNodes();\n\t\t\tthis.encoder.stop();\n\t\t\t\n\t\t\t// Will be resolved later when encoding finishes\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.stopPromiseResolve = resolve;\n\t\t\t});\n\t\t} else if (this.state == states.STARTING) {\n\t\t\tthis.state = states.STOPPING;\n\t\t\t\n\t\t\t// Will be rejected later when start() has completely finished operation\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.stopPromiseReject = reject;\n\t\t\t})\n\t\t}\n\t\t\n\t\tthrow new Error(\"Called stop when AudioRecorder was not started\");\n\t}\n\t\n\tstart(paused = false) {\n\t\tlet promise = this.__start(paused);\n\t\t\n\t\tpromise.catch(error => {\n\t\t\t// Don't send CancelStartError to onerror, as it's not *really* an error state\n\t\t\t// Only used as a promise rejection to indicate that starting did not succeed.\n\t\t\tif (error.name != \"CancelStartError\") {\n\t\t\t\tthis.onerror && this.onerror(error);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (!this.onerror) {\n\t\t\treturn promise;\n\t\t}\n\t}\n\t\n\tstop() {\n\t\tlet promise = this.__stop();\n\t\t\n\t\tpromise.catch(error => {\n\t\t\tif (error.name == \"CancelStartError\") {\n\t\t\t\t// Stop was called before recording even started\n\t\t\t\t// Send a onstop event anyway to indicate that recording can be retried.\n\t\t\t\tthis.onstop && this.onstop(this.options.streaming ? undefined : null);\n\t\t\t} else {\n\t\t\t\tthis.onerror && this.onerror(error);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (!this.onerror) {\n\t\t\treturn promise;\n\t\t}\n\t}\n\n\tpause() {\n\t\tif (this.state == states.RECORDING) {\n\t\t\tthis.state = states.PAUSED;\n\t\t\tthis.timer.stop();\n\t\t}\n\t}\n\n\tresume() {\n\t\tif (this.state == states.PAUSED) {\n\t\t\tthis.state = states.RECORDING;\n\t\t\tthis.timer.start();\n\t\t}\n\t}\n}\n","\nexport function stopStream(stream) {\n\tif (stream.getTracks) {\n\t\tstream.getTracks().forEach(track => track.stop());\n\t} else {\n\t\tstream.stop(); // Deprecated\n\t}\n}\n\n// https://stackoverflow.com/a/9039885\nexport function detectIOS() {\n\treturn [\n\t\t'iPad Simulator',\n\t\t'iPhone Simulator',\n\t\t'iPod Simulator',\n\t\t'iPad',\n\t\t'iPhone',\n\t\t'iPod'\n\t].includes(navigator.platform)\n\t\t// iPad on iOS 13 detection\n\t\t|| (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document);\n}\n\nexport function detectSafari() {\n\treturn /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n"],"names":["worker","workerState","workerStateChangeCallbacks","jobCallbacks","notifyWorkerState","newState","callback","loadWorker","workerUrl","test","URL","createObjectURL","Blob","type","Worker","onmessage","event","data","message","jobId","onencoded","srcBufLen","ondataavailable","onstopped","onerror","console","error","WorkerEncoder","constructor","options","this","replace","c","crypto","getRandomValues","Uint8Array","toString","queuedData","preload","waitForWorker","Promise","resolve","reject","push","Error","name","start","postMessage","command","sendData","buffers","length","getQueuedDataLen","stop","Timer","reset","startTime","stoppedTime","Date","now","resetAndStart","getTime","getAudioContextCtor","window","AudioContext","webkitAudioContext","DEFAULT_OPTIONS","recordingGain","encoderBitRate","streaming","streamBufferSize","forceScriptProcessor","constraints","channelCount","autoGainControl","echoCancellation","noiseSuppression","AUDIO_OUTPUT_MODULE_URL","state","audioContext","encoder","encodedData","stopPromiseResolve","stopPromiseReject","timer","isRecordingSupported","navigator","mediaDevices","getUserMedia","_workerUrl","useAudioWorklet","AudioWorklet","includes","platform","userAgent","document","createAndStartEncoder","numberOfChannels","originalSampleRate","sampleRate","mp3Blob","undefined","onstop","createOutputNode","log","outputNode","AudioWorkletNode","numberOfOutputs","port","_ref","createScriptProcessor","connect","destination","onaudioprocess","inputBuffer","i","getChannelData","createAudioNodes","recordingGainNode","createGain","setRecordingGain","sourceNode","createMediaStreamSource","stream","cleanupAudioNodes","getTracks","forEach","track","disconnect","close","gain","setTargetAtTime","currentTime","time","getEncodingQueueSize","stoppingCheck","createCancelStartError","__start","paused","Object","keys","audio","_AudioContext","audioWorklet","addModule","credentials","audioTracks","getAudioTracks","trackSettings","getSettings","getNumberOfChannels","onstart","startWasCancelled","__stop","promise","catch","pause","resume"],"mappings":"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"}